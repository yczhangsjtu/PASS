/*
 * CPASSREF/ntt.c
 *
 *  Copyright 2013 John M. Schanck
 *
 *  This file is part of CPASSREF.
 *
 *  CPASSREF is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  CPASSREF is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with CPASSREF.  If not, see <http://www.gnu.org/licenses/>.
*/

//#ifndef USE_FFTW
//#define USE_FFTW 1
//#endif


#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "constants.h"
#include "pass_types.h"
#include "ntt.h"

#define LENGTH_OF_HASH 64

#if USE_BLISS_NTT
static int64 roots512[512] = {
        1, 10302,  3400,  3150,  8340,  6281,  5277,  9407,
    12149,  7822,  3271,  1404, 12144,  5468, 10849, 10232,
     7311, 10930,  9042,    64,  8011,  8687,  4976,  5333,
     8736,  5925, 12176,  3329,  9048,   431,  3833,  3009,
     5860,  6152,  3531,   922, 11336,  1105,  4096,  8855,
     2963, 11239,  9509,  6099, 10530,  5057,  4143,  1489,
     3006, 11821,  8241,  6370,   480,  4782,  9852,   453,
     9275,  4075,  1426,  5297,  6534,  6415,  9377, 10314,
     4134,  7083,  9273,  8049,  6915, 11286,  2143,  6142,
    11112,  3789,  4414,  3728,  2731,  5241,  7205,   350,
     5023, 10256,  8779,  6507, 10908,  3600, 11287,   156,
     9542,  1973, 12129, 10695,  9005, 12138,  5101,  2738,
     3621,  6427, 10111,  1958,  5067,  8851, 10911,  9928,
     9198,  9606,  9984,  8527,  3382,  2049,  8585, 11026,
     2625,  6950,  3186, 10542,  5791,  8076,  2422,  4774,
     1170, 10120,  8653, 11089,   334, 12237,  5012,  7535,
     8246,  8724,  5191,  8243,  2396,  7280, 11082,  1954,
      726,  7540, 10600,  1146,  8652,   787,  9223,  9087,
     8961,  1254,  2969, 11606,  5331,   421, 11414,  5876,
    11227,  8775,  2166,  9597,  3289,  2505, 11899,   723,
     1212,   400,  3985,  8210,  6522,  5681,  5444,  9381,
     2366,  5445,  7394,  5766,  8595,  3445, 12047,  1583,
      563, 11907,  9405,  3834,  1022,  9260,  9302, 11871,
     7203,  4324, 10512,  3956,  4388,  6234,   354,  9364,
    11567,  9090,  3000, 11454,   130, 12048, 11885,  3963,
     2768,  5456, 10115,  6299,  6378,  9162,  7404, 10474,
     5728, 10367,  9424,  2948,  4177,  7665,  8005,  8320,
     9154, 11011,  7852,  5106,  5092,  8332,  9888,  2655,
     8785,  6874,  6730, 10211, 12171,   975,  4337,  9259,
    11289,  8471,  4053,  8273,  4231, 10968,  7270,  6374,
     4821,  6093, 10163,  9235,  9821,   605,  2187,  4737,
      955,  7210,  2704,  9734,  1428,  1323,  1045,   426,
     1479, 10587,  2399,  1319,  8993, 11404,  1168,  1805,
     1853,  4789,  8232, 11964,  6747,  1010,  8526,  5369,
    10938,  5435,  2686,  8633,  1673,  6068, 10682, 10258,
     4805,  1018,  4919,  7991, 11560, 10710,  3778,  1693,
     3195,  4948, 11813, 11848,  3748, 12147, 11796,  8760,
     7393,  7753,  5195,   295,  3707,  7591,  7575,  2500,
     9545,  8301, 10040,  7856,  9447,  6403,  8643,  6381,
     3201,  5315,  7635,  6170,  4632,   677,  6591,  3757,
     6553,  5529,   243,  8719,  2837,  3532, 11224,  2447,
     4255,   147,  2847,  8240,  8357,  9369,  1632,  1512,
     6461,  3998,  6957,  1566,  9764,  3263,  5011,  9522,
     4846,  5574,  9140,  1962,  9408, 10162, 11222,  6421,
     9744,  6136, 10745,  7967, 10092,  2844,  1912, 10446,
    12208,  1190,  7247,  2919,   355,  7377,  2678, 12240,
    11340,  5446,  5407,  9166, 11745, 11785,  6039,  6860,
     9970, 11767,  4938,  7105,  2426,  9115,  2481, 10431,
     5146, 11635,  9153,   709,  4452,  1956,  9041,  2051,
     4611,  5537,  8925, 11341,  3459,  8807,    27,  7796,
     5777, 11316,  3978,  9830,  7300,  8209,  8509,  2281,
     2294,  1041,  8374,   168, 10276,  5906,   773,   174,
    10643,  1728,  7384,  1058, 11462,  8812,  2381,   218,
     9238,  3860, 10805, 11637,  5179,  7509, 10752,  6347,
     9314,   316, 11136,  5257, 12280,  5594,  6267,  8517,
    10963,  4916,  1663,  1360,  1260,  3336,  7428, 11942,
     1305, 12233,   671,  6224,  7935, 12231,  4645, 11713,
     1635,  7840,  4372,  1159,  7399,  8120,  1017,  6906,
     4591,  8410,  2370,  9786,  8705,  6077,  5088,  3991,
     8577,  2344,     3,  6328, 10200,  9450,   442,  6554,
     3542,  3643, 11869, 11177,  9813,  4212, 11854,  4115,
     7969,  6118,  9644,  8212,  2548,   192, 11744,  1483,
     2639,  3710,  1630,  5486, 11950,  9987,  2566,  1293,
    11499,  9027,  5291,  6167, 10593,  2766,  9430,  3315
};

/*
 * FFT operation (forward and inverse).  
 *
 * BD: modified to use 32-bit arithmetic (don't use ntt32_muln), 
 * which is safe if q is less than 2^16.
 * Also forced intermediate results to be between 0 and q-1.
 */
static inline int64 sub_mod(int64 x, int64 y, int64 q) {
  x -= y;
  //  return x < 0 ? x + q : x;
  return x + ((x >> 63) & q);
}

static inline int64 add_mod(int64 x, int64 y, int64 q) {
  //  x += y;
  //  return x - q >= 0 ? x - q : x;
  x += y - q;
  return x + ((x >> 63) & q);
}


void ntt_fft(int64 v[], uint64 n, int64 q, const int64 w[]) {
  uint64 i, j, k, l;
  int64 x, y;

  // assert(good_arg(v, n, q));

  // bit-inverse shuffle
  j = n >> 1;
  for (i = 1; i < n - 1; i++) {       // 00..0 and 11..1 remain same
    if (i < j) {
      x = v[i];
      v[i] = v[j];
      v[j] = x;
    }
    k = n;
    do {
      k >>= 1;
      j ^= k;
    } while ((j & k) == 0);
  }

  // main loops
  l = n;         // BD: avoid division n/i in the loop
  for (i = 1; i < n; i <<= 1) {
    //    l = n / i;
    for (k = 0; k < n; k += i + i) {
      x = v[k + i];
      v[k + i] = sub_mod(v[k], x, q);
      v[k] = add_mod(v[k], x, q);
    }

    for (j = 1; j < i; j++) {
      y = w[j * l];
      for (k = j; k < n; k += i + i) {
        x = (v[k + i] * y) % q;
        v[k + i] = sub_mod(v[k], x, q);
        v[k] = add_mod(v[k], x, q);
      }
    }

    l >>= 1;
  }

  // assert(good_arg(v, n, q));
}

// Elementwise vector product  v = t (*) u.
// BD: modified to use 32 bit arithmetic
void ntt32_xmu(int64 v[], uint64 n, int64 q, const int64 t[], const int64 u[]) {
  uint64 i;
  int64 x;

  // multiply each element point-by-point
  for (i = 0; i < n; i++) {
    x = (t[i] * u[i]) % q;
    v[i] = x + ((x >> 63) & q); // v[i] = if x<0 then x+q else x
  }

  // assert(good_arg(v, n, q));

}

int ntt(int64* output, const int64* input){
  ntt32_xmu(output, PASS_N, PASS_p, input, roots512);         /* multiply by powers of psi                  */
	// memcpy(output, input, sizeof(int64)*PASS_N);
  ntt_fft(output, PASS_N, PASS_p, roots512);                /* result = ntt(input)                        */
	return 0;
}

#elif USE_NTRU_NTT
static int64_t roots512[512]  = {
  431, 862, 911, 1007, 1065, 1089, 1111, 1497,
  1707, 1724, 1822, 2014, 2130, 2178, 2222, 2229,
  2383, 2407, 2623, 2773, 2994, 3349, 3414, 3448,
  3644, 4028, 4123, 4153, 4159, 4245, 4260, 4356,
  4444, 4458, 4766, 4814, 4995, 5015, 5246, 5363,
  5546, 5567, 5791, 5851, 5988, 6698, 6725, 6828,
  6896, 7233, 7288, 7673, 8005, 8056, 8059, 8246,
  8306, 8318, 8331, 8490, 8493, 8520, 8712, 8819,
  8888, 8916, 9379, 9427, 9495, 9532, 9579, 9628,
  9879, 9990, 10030, 10369, 10423, 10492, 10719, 10726,
  10827, 10913, 11019, 11092, 11095, 11134, 11299, 11487,
  11557, 11582, 11699, 11702, 11737, 11953, 11976, 12819,
  13396, 13450, 13495, 13656, 13792, 14261, 14383, 14466,
  14576, 14703, 15323, 15346, 15547, 15691, 15827, 16010,
  16112, 16118, 16492, 16612, 16636, 16662, 16811, 16980,
  16986, 17040, 17415, 17424, 17633, 17638, 17725, 17776,
  17832, 17847, 18399, 18467, 18589, 18729, 18741, 18758,
  18779, 18854, 18990, 19064, 19091, 19139, 19158, 19209,
  19256, 19309, 19589, 19758, 19980, 20060, 20215, 20271,
  20307, 20341, 20587, 20738, 20846, 20984, 21001, 21079,
  21157, 21169, 21438, 21452, 21461, 21531, 21654, 21767,
  21826, 21885, 22003, 22038, 22184, 22190, 22229, 22268,
  22475, 22598, 22615, 22633, 22661, 22974, 23114, 23164,
  23199, 23223, 23379, 23398, 23404, 23474, 23535, 23569,
  23845, 23906, 23952, 24061, 24363, 24855, 24923, 24995,
  25107, 25417, 25577, 25638, 26021, 26359, 26792, 26900,
  26919, 26990, 27025, 27119, 27221, 27259, 27312, 27355,
  27409, 27557, 27584, 27829, 27979, 28021, 28055, 28079,
  28359, 28522, 28603, 28739, 28766, 28932, 29152, 29406,
  29843, 29873, 29985, 30087, 30261, 30271, 30646, 30689,
  30692, 30707, 31094, 31382, 31457, 31565, 31577, 31654,
  31915, 32020, 32213, 32224, 32236, 32265, 32313, 32553,
  32984, 33224, 33272, 33301, 33313, 33324, 33517, 33622,
  33883, 33960, 33972, 34080, 34155, 34443, 34830, 34845,
  34848, 34891, 35266, 35276, 35450, 35552, 35664, 35694,
  36131, 36385, 36605, 36771, 36798, 36934, 37015, 37178,
  37458, 37482, 37516, 37558, 37708, 37953, 37980, 38128,
  38182, 38225, 38278, 38316, 38418, 38512, 38547, 38618,
  38637, 38745, 39178, 39516, 39899, 39960, 40120, 40430,
  40542, 40614, 40682, 41174, 41476, 41585, 41631, 41692,
  41968, 42002, 42063, 42133, 42139, 42158, 42314, 42338,
  42373, 42423, 42563, 42876, 42904, 42922, 42939, 43062,
  43269, 43308, 43347, 43353, 43499, 43534, 43652, 43711,
  43770, 43883, 44006, 44076, 44085, 44099, 44368, 44380,
  44458, 44536, 44553, 44691, 44799, 44950, 45196, 45230,
  45266, 45322, 45477, 45557, 45779, 45948, 46228, 46281,
  46328, 46379, 46398, 46446, 46473, 46547, 46683, 46758,
  46779, 46796, 46808, 46948, 47070, 47138, 47690, 47705,
  47761, 47812, 47899, 47904, 48113, 48122, 48497, 48551,
  48557, 48726, 48875, 48901, 48925, 49045, 49419, 49425,
  49527, 49710, 49846, 49990, 50191, 50214, 50834, 50961,
  51071, 51154, 51276, 51745, 51881, 52042, 52087, 52141,
  52718, 53561, 53584, 53800, 53835, 53838, 53955, 53980,
  54050, 54238, 54403, 54442, 54445, 54518, 54624, 54710,
  54811, 54818, 55045, 55114, 55168, 55507, 55547, 55658,
  55909, 55958, 56005, 56042, 56110, 56158, 56621, 56649,
  56718, 56825, 57017, 57044, 57047, 57206, 57219, 57231,
  57291, 57478, 57481, 57532, 57864, 58249, 58304, 58641,
  58709, 58812, 58839, 59549, 59686, 59746, 59970, 59991,
  60174, 60291, 60522, 60542, 60723, 60771, 61079, 61093,
  61181, 61277, 61292, 61378, 61384, 61414, 61509, 61893,
  62089, 62123, 62188, 62543, 62764, 62914, 63130, 63154,
  63308, 63315, 63359, 63407, 63523, 63715, 63813, 63830,
  64040, 64426, 64448, 64472, 64530, 64626, 64675, 65106
};


/*
 * NTT pre-computed params for x^751-1 mod 65447
 */
static int64_t roots761[761]  =
{
  1, 58, 150, 362, 370, 503, 570, 585,
  768, 801, 882, 886, 952, 1187, 1230, 1341,
  1363, 1406, 1433, 1443, 1540, 1693, 1773, 1992,
  2005, 2006, 2073, 2092, 2125, 2166, 2223, 2272,
  2278, 2346, 2453, 2623, 2659, 2874, 3022, 3034,
  3046, 3193, 3245, 3348, 3364, 3399, 3525, 3541,
  3564, 3565, 3685, 3779, 3795, 3842, 4011, 4065,
  4162, 4215, 4243, 4439, 4530, 4674, 4716, 4793,
  4797, 4809, 5124, 5160, 5174, 5303, 5378, 5489,
  5541, 5570, 5642, 5788, 5852, 5893, 5908, 5912,
  6006, 6134, 6146, 6168, 6215, 6255, 6341, 6570,
  6628, 6634, 6719, 7062, 7143, 7347, 7574, 7618,
  7619, 7653, 7821, 7944, 8038, 8075, 8109, 8194,
  8412, 8469, 8507, 8695, 8700, 8905, 8942, 9037,
  9304, 9361, 9393, 9740, 9967, 9981, 9999, 10003,
  10027, 10080, 10086, 10110, 10221, 10247, 10334, 10349,
  10371, 10397, 10429, 10456, 10739, 10797, 10880, 10922,
  11024, 11129, 11174, 11219, 11237, 11278, 11380, 11429,
  11691, 11740, 11749, 11847, 11906, 11991, 12067, 12097,
  12148, 12181, 12193, 12237, 12261, 12331, 12449, 12495,
  12507, 12627, 12628, 12661, 12728, 13231, 13255, 13395,
  13426, 13476, 13537, 13547, 13554, 13565, 13607, 13796,
  14003, 14054, 14102, 14137, 14394, 14421, 14465, 14559,
  14654, 14715, 14777, 14785, 14804, 14841, 14990, 15265,
  15429, 15447, 15508, 15661, 15838, 15859, 15992, 16007,
  16017, 16056, 16101, 16206, 16228, 16248, 16417, 16438,
  16441, 16707, 16914, 16981, 16987, 17123, 17134, 17209,
  17214, 17389, 17425, 17455, 17600, 17667, 18003, 18048,
  18247, 18307, 18415, 18609, 18694, 18831, 18971, 19064,
  19362, 19387, 19517, 19608, 19638, 20053, 20109, 20124,
  20176, 20180, 20271, 20413, 20549, 20659, 20679, 20727,
  20821, 20918, 20996, 21039, 21113, 21166, 21213, 21218,
  21240, 21313, 21336, 21460, 21501, 21612, 21723, 21807,
  21933, 21992, 22063, 22120, 22248, 22303, 22372, 22500,
  22546, 22604, 22758, 22841, 22906, 23302, 23328, 23355,
  23501, 23608, 23617, 23690, 23705, 23769, 23823, 23843,
  23873, 24021, 24099, 24120, 24266, 24298, 24573, 24575,
  24632, 24665, 24840, 24864, 24922, 24938, 24939, 24966,
  25005, 25030, 25253, 25494, 25623, 25841, 25978, 26126,
  26145, 26187, 26209, 26246, 26405, 26450, 26495, 26609,
  26810, 26857, 26944, 26972, 26989, 27313, 27628, 27654,
  27689, 27758, 27869, 27938, 28174, 28220, 28280, 28382,
  28537, 28621, 28819, 28905, 28917, 28945, 29174, 29233,
  29572, 29667, 29763, 29767, 29768, 29820, 30088, 30101,
  30189, 30217, 30251, 30509, 30685, 30821, 31119, 31212,
  31318, 31429, 31446, 31581, 31696, 31769, 32043, 32170,
  32360, 32467, 32549, 32552, 32557, 32656, 32747, 33041,
  33060, 33073, 33139, 33175, 33204, 33235, 33244, 33268,
  33333, 33344, 33444, 33839, 33904, 33930, 34529, 34559,
  34563, 34582, 34598, 34659, 34718, 34834, 34892, 34897,
  34970, 35005, 35063, 35198, 35234, 35277, 35327, 35351,
  35389, 35404, 35555, 35798, 35928, 35989, 36060, 36078,
  36161, 36190, 36283, 36297, 36351, 36431, 37012, 37100,
  37146, 37175, 37203, 37320, 37387, 37492, 37708, 37833,
  37986, 38041, 38304, 38349, 38418, 38818, 38962, 39095,
  39112, 39236, 39272, 39312, 39429, 39467, 39517, 39722,
  39925, 40122, 40315, 40472, 40494, 40539, 40543, 40680,
  40715, 40840, 40898, 41008, 41011, 41012, 41244, 41344,
  41734, 41789, 41860, 42017, 42216, 42312, 42346, 42432,
  42576, 42628, 42635, 42708, 42981, 43047, 43227, 43244,
  43267, 43274, 43298, 43437, 43482, 43534, 43940, 44071,
  44084, 44103, 44161, 44236, 44364, 44382, 44392, 44453,
  44544, 44611, 44612, 44819, 44845, 44958, 45046, 45055,
  45078, 45115, 45379, 45416, 45650, 45674, 45774, 45786,
  45840, 45841, 45911, 46181, 46224, 46300, 46458, 46471,
  46508, 46610, 46627, 46630, 46675, 46812, 46891, 47037,
  47069, 47093, 47095, 47141, 47153, 47156, 47256, 47427,
  47430, 47481, 47499, 47524, 47625, 47869, 47882, 48067,
  48129, 48183, 48577, 48653, 48683, 48752, 48822, 48873,
  49162, 49220, 49333, 49340, 49375, 49488, 49529, 49582,
  49676, 49699, 49753, 50081, 50089, 50114, 50136, 50234,
  50369, 50475, 50490, 50570, 50843, 50847, 50851, 50885,
  50901, 50963, 50964, 51054, 51156, 51192, 51291, 51388,
  51547, 51711, 51721, 51978, 52012, 52028, 52308, 52392,
  52425, 52578, 52598, 52721, 52724, 52748, 52803, 52930,
  52936, 52941, 52976, 53166, 53392, 53533, 53606, 53723,
  53825, 53874, 54083, 54118, 54123, 54252, 54269, 54300,
  54510, 54593, 54703, 54787, 54898, 54960, 54967, 55131,
  55215, 55216, 55276, 55322, 55326, 55493, 55494, 55500,
  55525, 55790, 55813, 55889, 55917, 56083, 56142, 56183,
  56366, 56459, 56574, 56598, 56668, 56731, 56799, 56962,
  56993, 57118, 57189, 57316, 57471, 57496, 57521, 57527,
  57537, 57609, 57803, 57841, 57990, 57999, 58007, 58108,
  58361, 58461, 58505, 58560, 58683, 58791, 58944, 59058,
  59069, 59095, 59339, 59378, 59442, 59496, 59590, 59612,
  59726, 60016, 60081, 60164, 60181, 60235, 60324, 60326,
  60377, 60507, 60551, 60616, 60617, 60618, 60714, 60728,
  60757, 60805, 60846, 60849, 60864, 60911, 60936, 60968,
  61014, 61064, 61072, 61121, 61272, 61317, 61412, 61421,
  61507, 61532, 61534, 61535, 61665, 61679, 61684, 61691,
  61846, 61881, 62046, 62091, 62325, 62418, 62467, 62469,
  62623, 62723, 62804, 62835, 63112, 63119, 63125, 63290,
  63364, 63470, 63487, 63667, 63868, 63888, 64147, 64175,
  64216, 64218, 64237, 64480, 64491, 64530, 64552, 64568,
  64629, 64699, 64754, 64796, 64850, 65079, 65080, 65101,
  65229
};

int64 modq(int64 a, int64 q)
{
  int64 b = a%q;
  if (b<0)
    return q+b;
  else
    return b;
}

int ntt(int64 *f_ntt, const int64 *f)
{
  uint16 i,j;
  int64 base, tmp;
  memset(f_ntt, 0, sizeof(int64)*PASS_N);

  if (PASS_N%2==0)
  {
    int64 odd,even;
    for (i=0;i<PASS_N/2;i++)
    {
      odd  = f[0];
      even = f[0];
      base = 1;
      for (j=1;j<PASS_N;j++)
      {
        base = base*PASS_ROOTS[i] % PASS_p;
        tmp = f[j]*base;
        even = even + tmp;
        if (j%2==0)
          odd = odd + tmp;
        else
          odd = odd + PASS_p - tmp;
      }
      f_ntt[i]= even % PASS_p;
      f_ntt[PASS_N-1-i] = odd % PASS_p;
    }
  }
  else
  {
    for (i=0;i<PASS_N;i++)
    {
      base = 1;
      f_ntt[i]  = f[0];
      for (j=1;j<PASS_N;j++)
      {
        base = base*PASS_ROOTS[i] % PASS_p;
        f_ntt[i] += f[j]*base;

      }
      f_ntt[i] %= PASS_p;
    }
  }
	return 0;
}
#elif USE_ORIGINAL_NTT
#if USE_FFTW
#include <complex.h>
#include <math.h>
#include </usr/include/fftw3.h>
#endif

#include "poly.h"

static int NTT_INITIALIZED = 0;

#if USE_FFTW
static fftw_plan DFT;
static fftw_plan iDFT;

static fftw_real *dpoly = NULL;
static fftw_complex *cpoly = NULL;
static fftw_complex *nth_roots_dft = NULL;
#endif

#if USE_FFTW
int
ntt_setup() {
  fftw_plan DFTom;

fftw_real nth_roots[NTT_LEN] = {
#include PASS_RADER_POLY
  };

  if(!NTT_INITIALIZED) {
    NTT_INITIALIZED = 1;

    if(!fftw_import_wisdom_from_filename(PASS_WISDOM)) goto error;

    dpoly = fftw_alloc_real(NTT_LEN);
    if(dpoly == NULL) goto error;

    nth_roots_dft = fftw_alloc_complex(NTT_LEN);
    if(nth_roots_dft == NULL) goto error;

    cpoly = fftw_alloc_complex(NTT_LEN);
    if(cpoly == NULL) goto error;

    DFTom = fftw_plan_dft_r2c_1d(NTT_LEN, nth_roots, nth_roots_dft,
        FFTW_WISDOM_ONLY | FFTW_PATIENT);
    if(DFTom == NULL) goto error;

    fftw_execute(DFTom);
    fftw_destroy_plan(DFTom);

    DFT = fftw_plan_dft_r2c_1d(NTT_LEN, dpoly, cpoly,
        FFTW_WISDOM_ONLY | FFTW_PATIENT);
    if(DFT == NULL) goto error;

    iDFT = fftw_plan_dft_c2r_1d(NTT_LEN, cpoly, dpoly,
        FFTW_WISDOM_ONLY | FFTW_PATIENT);
    if(iDFT == NULL) goto error;
  }
  return 0;
error:
  ntt_cleanup();
  return -1;
}

int
ntt_cleanup() {
  if(NTT_INITIALIZED) {
    NTT_INITIALIZED = 0;
    fftw_destroy_plan(DFT);
    fftw_destroy_plan(iDFT);
    fftw_free(dpoly);
    fftw_free(cpoly);
    fftw_free(nth_roots_dft);
    fftw_cleanup();
  }
  return 0;
}

int
ntt(int64 *Ff, const int64 *f)
{
  int i;

  for(i=0; i<NTT_LEN; i++){
    dpoly[i] = (fftw_real) f[perm[i]];
  }

  fftw_execute(DFT); /* dpoly -> cpoly */

  for(i=0;i<(NTT_LEN/2)+1; i++){
    cpoly[i] *= nth_roots_dft[i];
  }

  fftw_execute(iDFT); /* cpoly -> dpoly */

  for(i=0; i<NTT_LEN; i++) {
    Ff[perm[NTT_LEN-i]] = f[0] + llrint(dpoly[i]/NTT_LEN);
  }

  poly_cmod(Ff);

  return 0;
}

#else /* Not using FFTW */

int

ntt_setup() {
  NTT_INITIALIZED = 1;
  return 0;
}

int
ntt_cleanup() {
  NTT_INITIALIZED = 0;
  return 0;
}

int
ntt(int64 *Fw, const int64 *w)
{
  int64 i;
  int64 j;

	int64 nth_roots[NTT_LEN] = {
#include PASS_RADER_POLY
	};

  /* Rader DFT: Length N-1 convolution of w (permuted according to
   * PASS_PERMUTATION) and the vector [g, g^2, g^3, ... g^N-1].
   *
   * TODO: Certainly faster to always store coefficients in multiplicative
   * order and just perform permutation when publishing z or extracting
   * coefficients.
   */

  for (i = 0; i < NTT_LEN; i++) {
    Fw[perm[i]] += w[0]; /* Each coefficient of Fw gets a w[0] contribution */

    if (w[perm[i]] == 0) continue;

    for (j = i; j < NTT_LEN; j++) {
      Fw[perm[NTT_LEN-j]] += (w[perm[i]] * nth_roots[j-i]);
    }

    for (j = 0; j < i; j++) {
      Fw[perm[NTT_LEN-j]] += (w[perm[i]] * nth_roots[NTT_LEN+j-i]);
    }
  }

  /* Fw[0] (evaluation of w at 1). */
  for (i = 0; i < PASS_N; i++) {
    Fw[0] += w[i];
  }

  poly_cmod(Fw);

  return 0;
}
#endif
#endif
